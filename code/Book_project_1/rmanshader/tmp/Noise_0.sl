/*
** Copyright (c) 2001 PIXAR.  All rights reserved.  This program or
** documentation contains proprietary confidential information and trade
** secrets of PIXAR.  Reverse engineering of object code is prohibited.
** Use of copyright notice is precautionary and does not imply
** publication.
**
**                      RESTRICTED RIGHTS NOTICE
**
** Use, duplication, or disclosure by the Government is subject to the
** following restrictions:  For civilian agencies, subparagraphs (a) through
** (d) of the Commercial Computer Software--Restricted Rights clause at
** 52.227-19 of the FAR; and, for units of the Department of Defense, DoD
** Supplement to the FAR, clause 52.227-7013 (c)(1)(ii), Rights in
** Technical Data and Computer Software.
**
** Pixar
** 1200 Park Ave
** Emeryville, CA 94608
**
** ----------------------------------------------------------------------------
*/
/* code generated by slim 6.0, RAT 6.0 (Mar 11 2004 04:21:00) */
/* for kidd@localhost at: Sat Mar 26 16:31:50 FLE Standard Time 2005 */

/* includes ---------------------------------*/

/* defines ----------------------------------*/
#define SLIM_TYPEID_surface 0
#define SLIM_TYPEID_displacement 1
#define SLIM_TYPEID_volume 2
#define SLIM_TYPEID_light 3
#define SLIM_VERSION 600
#define SLIM_SHADERTYPE surface
#define SLIM_SHADERTYPEID SLIM_TYPEID_surface
#define SLIM_INSTANCETYPE color
#define SLIM_INSTANCENAME Noise_0

/* shader body ------------------------------*/
SLIM_SHADERTYPE
SLIM_INSTANCENAME (
)
{

/* static functions ----------------------*/

	    void pxslMayaUV (
		point STMatrix0;
		point STMatrix1;
		output point Q; 
		output vector dQu;
		output vector dQv;
	    ) 
	    {
		extern float s, t, du, dv;
	    	setzcomp(Q, 0);
		if ( STMatrix0 == point(1,0,0) &&
		     STMatrix1 == point(0,1,0) )
		{
		    /* no connection has been made, convert from
		    	std Maya to std RenderMan parameterization
			for nurbs. */
		    setxcomp(Q, t);
		    setycomp(Q, 1-s);
		}
		else
		{
		    setxcomp(Q, vector(s, t, 1) . 
		    	    	vector(transform("shader", STMatrix0)) );
		    setycomp(Q, vector(s, t, 1) . 
		    	    	vector(transform("shader", STMatrix1)) );
		}
		dQu = vector Du(Q)*du;
		dQv = vector Dv(Q)*dv;
	    }
	

#include "pxslUtil.h"
    	void
	pxslCNoise( float frequency;
	    	    point p;
		    vector dpu;
		    vector dpv;
		    output color result;
		   )
	{
	    point pp = frequency * p;
	    vector dppu = frequency * dpu;
	    vector dppv = frequency * dpv;
	    result = pxslFilteredCNoise(pp, dppu, dppv);
	}
    

/* dynamic functions ------------------------*/

/* local variables --------------------------*/
  point tmp0;
  color tmp3;
  vector tmp1;
  vector tmp2;

/* main body --------------------------------*/
  pxslMayaUV ( /* MayaUV_0 */
    point(1,0,0), /* STMatrix0 */
    point(0,1,0), /* STMatrix1 */
    tmp0, /* Q */ 
    tmp1, /* dQu */ 
    tmp2  /* dQv */ 
    );
  pxslCNoise ( /* Noise_0 */
    10.9, /* frequency */
    tmp0, /* p */ 
    tmp1, /* dpu */ 
    tmp2, /* dpv */ 
    tmp3  /* result */ 
    );
  Ci = tmp3;
  Oi = color(1,1,1);
}

