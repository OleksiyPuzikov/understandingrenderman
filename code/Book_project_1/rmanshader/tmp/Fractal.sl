/*
** Copyright (c) 2001 PIXAR.  All rights reserved.  This program or
** documentation contains proprietary confidential information and trade
** secrets of PIXAR.  Reverse engineering of object code is prohibited.
** Use of copyright notice is precautionary and does not imply
** publication.
**
**                      RESTRICTED RIGHTS NOTICE
**
** Use, duplication, or disclosure by the Government is subject to the
** following restrictions:  For civilian agencies, subparagraphs (a) through
** (d) of the Commercial Computer Software--Restricted Rights clause at
** 52.227-19 of the FAR; and, for units of the Department of Defense, DoD
** Supplement to the FAR, clause 52.227-7013 (c)(1)(ii), Rights in
** Technical Data and Computer Software.
**
** Pixar
** 1200 Park Ave
** Emeryville, CA 94608
**
** ----------------------------------------------------------------------------
*/
/* code generated by slim 6.0, RAT 6.0 (Mar 11 2004 04:21:00) */
/* for kidd@localhost at: Sat Mar 26 16:25:32 FLE Standard Time 2005 */

/* includes ---------------------------------*/

/* defines ----------------------------------*/
#define SLIM_TYPEID_surface 0
#define SLIM_TYPEID_displacement 1
#define SLIM_TYPEID_volume 2
#define SLIM_TYPEID_light 3
#define SLIM_VERSION 600
#define SLIM_SHADERTYPE surface
#define SLIM_SHADERTYPEID SLIM_TYPEID_surface
#define SLIM_INSTANCETYPE color
#define SLIM_INSTANCENAME Fractal

/* shader body ------------------------------*/
SLIM_SHADERTYPE
SLIM_INSTANCENAME (
  string SurfacePoint_Space="";
  varying point __Pref=point(-1e10,-1e10,-1e10);
)
{

/* static functions ----------------------*/

		void pxslSurfacePoint (
		    uniform string coordsys;
		    uniform float frequency;
		    uniform float ignorePref;
		    output point Q; 
		    output vector dQu;
		    output vector dQv;
		) 
		{
		    extern point P, Ps;
		    extern vector dPdu, dPdv;
		    extern point __Pref;
		    extern float du, dv;
		    uniform string sys;

		    if(coordsys == "")
		    	sys = "shader";
		    else
		    	sys = coordsys;
#if SLIM_SHADERTYPEID == SLIM_TYPEID_light
		    if (ignorePref == 0 && 1 == surface("__Pref", Q))
		    {
			Q = frequency * transform(sys, Q);
		    }
		    else
		    {
		    	Q = frequency * transform(sys, Ps);
		    }
		    dQu = vector Du(Q)*du;
		    dQv = vector Dv(Q)*dv;
#else
		    if (xcomp(__Pref) == -1e10 || ignorePref != 0)
		    {
			Q = frequency * transform (sys, P);
		    	dQu = vtransform (sys, dPdu*du*frequency);
		    	dQv = vtransform (sys, dPdv*dv*frequency);
		    }
		    else 
		    {
			Q = frequency * transform (sys, __Pref);
			dQu = vector Du(Q)*du;
		        dQv = vector Dv(Q)*dv;
		    }
#endif
		}
	    

	    	void pxslC_Fractal (
		    float	Layers;
		    float	Frequency;
		    float	Lacunarity;
		    float	Dimension;
		    float	Erosion;
		    float	Measure;
		    float	Variation;
		    point	Q;
		    vector	duQ;
		    vector	dvQ;
		    output color	result;
		)
		{
		    color Noise (point Q)
		    {
			extern float	Variation;
			color	C;
			
			C = color noise (Q, Variation);
			C = color (
			    smoothstep (.2, .8, comp (C, 0)),
			    smoothstep (.2, .8, comp (C, 1)),
			    smoothstep (.2, .8, comp (C, 2))
			);
			return (C);
		    }
		    
		    float
		    Distance (float type; color C)
		    {
			float	result;

			if (type == 1)	/* Saturation */
			    result = comp (ctransform ("RGB", "HSY", C), 1);

			else if (type == 2)	/* Luminance */
			    result = comp (ctransform ("RGB", "HSY", C), 2);

			else	/* Gray */
			    result = length (vector (C - color .5)) + .319;
			
			return (result);
		    }
		    
		    uniform float	i;
		    float	sum, mag, f, offset;
		    float	dQ;
		    
		    dQ = max (
			max (
			    abs(xcomp(duQ)) + abs(xcomp(dvQ)),
			    abs(ycomp(duQ)) + abs(ycomp(dvQ))
			),
			abs(zcomp(duQ)) + abs(zcomp(dvQ))
		    );

		    f = Frequency;
		    result = mix (Noise (f*Q), color .5, smoothstep (.25, 1, f*dQ));
		    sum = 1;

		    for (i=1; i < Layers; i+=1) {
			f *= Lacunarity;
			offset = mix (-Erosion, Erosion,
			    Distance (Measure, result/sum)
			);
			mag = 1/pow (f, 3-2*Dimension + offset);
			result += mag*mix (Noise (f*Q), color .5, smoothstep (.25, 1, f*dQ));
			sum += mag;
		    }

		    result /= sum;
		}
	    

/* dynamic functions ------------------------*/

/* local variables --------------------------*/
  point tmp0;
  color tmp3;
  vector tmp1;
  vector tmp2;

/* main body --------------------------------*/
  pxslSurfacePoint ( /* SurfacePoint */
    SurfacePoint_Space, /* Space */
    1, /* Frequency */
    0, /* IgnorePref */
    tmp0, /* Q */ 
    tmp1, /* dQu */ 
    tmp2  /* dQv */ 
    );
  pxslC_Fractal ( /* Fractal */
    6, /* Layers */
    1, /* Frequency */
    2, /* Lacunarity */
    1, /* Dimension */
    0, /* Erosion */
    0, /* Erosion Measure */
    0, /* Variation */
    tmp0, /* Q */ 
    tmp1, /* duQ */ 
    tmp2, /* dvQ */ 
    tmp3  /* result */ 
    );
  Ci = tmp3;
  Oi = color(1,1,1);
}

