 \chapter*{Gelato}
  

 Появления этого продукта ожидали многие. Ещё не
    было достоверно известно, что он существует, но все понимали, что
    внутри Nvidia что-то варится. Не могло не вариться – как не может
    критическая масса внутри атомной бомбы не взорваться.
  

 Но – будем рассказывать по порядку.
  

 В июле 2000го года три человека – Ларри Гритц, Мэтт
    Фарр и Крэг Колб (Larry Gritz, Matt Pharr, Craig Kolb) объединили
    свои усилия, чтобы создать новый Renderman-совместимый рендерер.
    Ларри внёс в копилку знаний свой рендерер BMRT и опыт работы в
    Pixar над prman’ом и интеграцией prman и BMRT (помните, как я,
    рассказывая о возможностях расширения SL, кратко упомянул
    Frankenrender?). Мэтт положил в пул свою идею (и написанную на её
    основе диссертацию) о кардинальном ускорении процесса raytracing’а
    – и опыт работы в Pixar над prman. Крэг – опыт, накопленный в ходе
    разработки рендерера Rayshade. Объединившись под вывеской Exluna
    (“На Луну!”) (для любознательных – латынь язык интересный и не
    всегда однозначный; переводом названия Exluna могут также служить
    «с луны» или «не на луне») и выбрав в качестве логотипа мультяшный
    космический кораблик, разработчики сделали почти невозможное – в
    августе 2001го года представили на суд публике новый рендерер –
    Entropy. Качественный, быстрый, Renderman-совместимый рейтрейсер
    превосходил prman по набору поддерживаемых алгоритмов рендеринга и
    стоил всего полторы тысячи долларов (не случайно считается, что
    именно после появления Entropy в Pixar серьёзно озаботились
    встраиванием ray tracer’а в Renderman Pro Server – хотя скорее
    всего, это не так и работы шли параллельно) – а значит, был гораздо
    дешевле.
  

 Entropy был хитом и раскупался, как пирожки. Почва
    под ногами prman зашаталась, и ответный ход не заставил себя ждать
    – к сожалению, он был не совсем приятным. 5го марта 2002го года
    Pixar подала на Exluna в суд, обвиняя комнанию в нарушении
    патентов, а 16го мая – во втором иске обвинила трио основателей в
    плагиате (ведь два из них ранее работали в Pixar и видели исходный
    код prman). Тщетно адвокаты молодой компании пытались бороться –
    куда стартапу из 10 человек на втором году жизни было тягаться
    против гиганта Pixar (с Диснеем за спиной). И несмотря на то, что
    причин для судебного разбирательства не было и патенты не
    нарушались – лучшим выходом для Exluna оказалось прекратить продажи
    своего продукта, продаться Nvidia с потрохами и дать победителям
    урегулировать споры между собой.
  

 К этому моменту сложилась, можно сказать,
    интересная ситуация – в Nvidia одновременно оказались несколько
    разработчиков рендереров: Джакопо Панталеони (Jacopo Pantaleoni),
    автор LightFlow; троица из Exluna; Дэниэл Векслер (Daniel Wexler),
    создатель рендерера, который PDI/Dreamworks использовали в фильмах
    Antz и Shrek. По совокупности одновременно находящихся в компании
    именитых рендерописателей Nvidia вышла на первое место в
    индустрии  – и это
    могло означать только одно – у Entropy готовится
    преемник.
  

 Таким преемником оказался новый рендерер Gelato,
    анонсированный 19 апреля 2004го года.
  

 Основной особенностью Gelato, из-за которой его так
    любит пресса и так не любят некоторые разработчики и TD, является
    то, что это первый продакшн рендерер, который использует
    возможности вашей видеокарты для рендеринга – и более того, не
    работает, если у вас не установлена определённая видеокарта –
    конечно же, с чипом от Nvidia. Чтобы понять, насколько серьёзное
    преимущество оказывается в руках у тех, кто берёт на вооружение
    новый рендерер, отвлечёмся немного и поговорим о процессорах,
    Законе Мура и современных реалиях.
  

 Как гласит закон Мура, число транзисторов на
    современном компьютерном микропроцессоре удваивается каждые 2 года.
    Этот закон был сформулирован в 1965ом году, работает до сих пор и
    по оценкам исследователей – будет работать ещё с десяток лет.
    Казалось бы, всё отлично - до недавних пор формулировка закона
    означала, что каждые два года мы получаем в свои руки как минимум
    вдвое больше производительности – но, как показывает опыт, в
    последнее время рост производительности центральных
    микропроцессоров (CPU) практически прекратился, несмотря на
    продолжающийся рост сложности их конструкции, числа транзисторов и
    тактовой частоты. Производители микропроцессоров (Intel, AMD, Sun,
    IBM и другие) стараются изо всех сил, придумывая и воплощая в жизнь
    новые технологии и идеи – но предложить что-то кардинально новое, в
    очередной ускоряющее вычисления в 2 раза, увы – не в состоянии. В
    ближайшее время нас ждёт нашествие многоядерных решений, в которых
    за счёт фактического объединения 2х процессоров в один будет
    сделана попытка обмануть закон Мура и опять удвоить
    производительность – но проблема налицо – сделать персональный
    компьютер с центральным процессором, в 2 раза быстрее сегодняшнего,
    сложно и очень затратно (хотя, как показывает практика -
    можно).
  

 С другой стороны, в мире процессоров, применяющихся
    в видеоускорителях (GPU) всё складывается гораздо интереснее –
    требования по поддержке всё новых и новых стандартов (DirectX,
    OpenGL, шейдеры), по увеличению качества рендеринга во всё новых и
    новых приложениях и особенно – в играх – привели к тому, что сугубо
    специализированные ускорители отрисовки треугольников превратились
    в универсальные процессоры данных, позволяющие программировать себя
    и обладающие рядом уникальных свойств. При этом для GPU закон Мура
    не выполняется – потому что скорость у них не удваивается каждые 2
    года, а чуть ли не удесятеряется – ведь эти процессорами не тяготит
    груз совместимости и необходимость запускать операционную систему.
    Было бы глупо не попытаться использовать такой мощный
    дополнительный универсальный вычислитель для ускорения работы
    основного процессора – и такие попытки делались и делаются, и всё
    больше программ умеют использовать “дармовые” мощности. Но первыми,
    кто смог оптимизировать для GPU готовый к производству рендерер,
    стали сотрудники Nvidia.
  

 Итак, для запуска Gelato вам понадобится
    современный мощный компьютер под управлением Windows XP или Linux –
    и современная-же мощная профессиональная видеокарта на чипсете от
    Nvidia – в частности, Quadro FX. Прежде чем мы попробуем новый
    рендерер в бою (вы тоже можете это сделать – тестовая версия Gelato
    доступна для скачивания на сайте; единственное ограничение этой
    версии – водяной знак на результатах рендеринга), рассмотрим кратко
    основные черты этого продукта.
  
     Gelato – полноценный production renderer
      (удовлетворяющий нашему списку требований), взявший за основу
      Entropy и BMRT и добавивший в них множество новых
      свойств
     Gelato – современный рендерер. В нём нет поддержки
      многих устаревших режимов и видов геометрии, которые не нужны при
      выполнении реальных задач. Что там говорить – такой геометрический
      примитив, как сфера, появился в рендерере уже в самом конце
      бета-теста по настоятельным просьбам тестеров – привыкшим к
      использованию шариков в своих тестовых сценах. С другой стороны,
      Gelato поддерживает все современные технологии – ray tracing,
      ambient occlusion, caustics и многие другие.
     Gelato не является Renderman-совместимым рендерером
      (Nvidia решила не играть в кошки-мышки с Pixar),  но взял от былой совместимости
      всё самое лучшее. Например, в этом рендерере есть свой собственный
      язык шейдеров GSL – на 90 процентов совместимый с языком SL и
      переводимый из него при помощи несложного конвертера (неопытный
      пользователь может перепутать шейдеры, настолько они похожи).
      Возвращаясь к предыдущему пункту – над языком GSL основательно
      поработали, улучшив его новыми конструкциями и убрав устаревшие – и
      теперь в роли догоняющей оказалась уже Pixar.
  
  

 Если посмотреть правде не куда нибудь, а в
    конкретное место – перечислять инновации Gelato вот таким сухим
    списком скучновато не только для вас, но и для меня самого. Давайте
    лучше попробуем сделать что-нибудь в Maya и отрендерить в Gelato –
    а заодно и поговорим о достоинствах этого рендерера.
  

 Итак, в поставке Gelato (для тех, кто не знает –
    это такой сорт мягкого мороженого) идёт (продолжая вкусную тему)
    Mango  – плагин к Maya,
    который (в отличие от MTOR) встраивается в неё почти без проблем и
    позволяет использовать всю мощь обоих продуктов.
  

 Создадим новый проект, новую сцену, импортируем
    нашу овечку (файл sheep.ma на диске). Овечка у нас полигональная,
    если вы ещё не заметили – так что быстренько переводим её в
    Subdivision Surfaces: Modify => Convert => Polygon to Subdiv.
    Рендерим стандартным движком Maya – движок немного притормаживает –
    наконец получаем картинку:
  

 \gr{image065}
  

 Все наши предыдущие картинки с овцой были на чёрном
    фоне, который уже немного надоел – поэтому мы вставили в сцену
    большой шарик, который и дал нам серенький фон. Надоест и этот фон
    – уберём и его и будем опять смотреть на чёрный задник, но пока
    нормально и так. Да, на чём мы там остановились? Ах, да,
    Gelato.
  

 Если рендерер у вас установился правильно, то всё,
    что вам нужно сделать – это включить плагин обычным способом и
    вызвать окно Render Globals:
  

 \gr{image067}
  

 Переключаем рендерер, запускаем просчёт опять,
    слышим, как заработал вентилятор на видеокарте, ненадолго появилась
    и сразу же исчезла командная строка – и получаем прямо в окошке
    Render View результат:
  

 \gr{image069}
  

 Не нужно иметь зрение горного орла, чтобы увидеть,
    что рендеринг прошёл гораздо быстрее и в результате мы получили
    гораздо более качественную картинку – не меняя при этом установок
    по умолчанию в обоих рендерерах. При этом Gelato подхватил все
    установки Maya и воспроизвёл их своими средствами.
  

 Что произошло за кадром, пока мы слушали песню
    вентилятора нашей Nvidia GeForce QuadroFX 3000 (кстати, пока я это
    писал – вентилятор уже выключился)? Заглянем в директорию c:\\temp –
    в ней появились 3 новых файла:
  
gelato.pyg
gelato.bat
gelato\_perspShape.pyg
  

 Внутри этих файлов находится самое интересное –
    геометрия, которую Mango экспортировал из Maya в собственный формат
    Gelato. Правильнее говоря – Mango эскпортировал в формат PYG – один
    из форматов, поддерживаемых Gelato. Казалось бы, разница между
    двумя фразами минимальна, но она показывает глубокое философское
    различие между Gelato и другими рендерерами; одно из тех различий,
    на которых мы остановимся, и которое может вас удивить.
  

 Различие это состоит в том, что в Gelato нет
    формата сцены по умолчанию. Формат шейдера есть (GSL), а формата
    сцены – нет. Вместо этого пользователю представляется хорошо
    документированный программный интерфейс API и возможность написать
    в соответствии с этим интерфейсом плагин к рендереру,
    который  и будет
    заниматься вопросами загрузки геометрии. Понятное дело, что взять и
    просто так выпустить на рынок рендерер, в который по умолчанию
    нельзя загрузить геометрию вообще – это глупость, поэтому для
    Gelato придумали свой собственный формат PYG, представляющий из
    себя – программу на языке Python. В общем, смотрите сами, перед
    вами кусочек файла с овечкой:
  

World()
PushTransform()
SetTransform(((0.736097, 0, -0.676876, 0),
                (-0.130758, 0.981164, -0.142198, 0),
                (-0.664126, -0.193179, -0.722232, 0),
                (17.6053, 12.845, 21.3661, 1)))
Light("mayaDefaultLight", "distantlight", "point to", (0.5, -0.5, 1))
PopTransform()
PushAttributes()
Attribute("string name", "sheep:sheep")
AppendTransform ( ((1, 0, 0, 0),
                    (0, 1, 0, 0),
                    (0, 0, 1, 0),
                    (0, 0, 0, 1)) )
  

 Очень похоже на RIB (что неудивительно) – но это не
    обычный текстовый файл, а минипрограмма. Значит, мы можем взять – и
    сделать из неё настоящую программу, например, написать цикл или
    загрузить данные из другого файла или прочитать ввод пользователя
    из консоли или даже загрузить данные из Интернета – в нашем
    распоряжении вся мощь языка программирования Python!
  

 Энтузиасты Renderman немного скривились – в их
    руках такой мощной игрушки нет. А мы тем временем нанесём им ещё
    один удар – загрузив с сайта Nvidia плагин к Gelato, который
    позволяет использовать в качестве файлов геометрии – RIB-файлы.
    Действительно – а почему бы и нет, если есть открытый API?
    Попробуем эту возможность в бою – временно откладываем в сторону
    Maya и вызываем командную строку:
  

gelato test2.rib
  

 и немедленно получаем на экране окно с результатами
    рендеринга:
  

 \gr{image071}
  

 Как видно, Gelato без особых проблем справился с
    RIBом – благо шейдер “Plastic”, который мы использовали с нашей
    тестовой сцене, входит в поставку – равно как и все остальные
    шейдеры из стандарта Renderman - сказывается Entropy-шное
    прошлое.
  

 Это самое прошлое не раз будет напоминать о себе в
    наших изысканиях. Раз уж мы начали копаться в командной строке –
    посмотрим, например, из чего же состоит наш новый друг. Ба! Налицо
    уже набившая нам оскомину триада – рендерер, компилятор шейдеров и
    конвертор текстур – на этот раз они называются gelato.exe, gslc.exe
    и maketx.exe.
  

 Внутри директории gelato/bin ещё много всего
    интересного, например, утилита topyg, которая позволяет перевести
    любой из поддерживаемых установленных вами плагинами форматов
    геометрии в PYG – с её помощью можно сравнить одну и ту же сцену в
    формате PYG и RIB и увидеть явные аналогии. А мы возвращаемся к
    нашим баранам – я хотел сказать, к нашей овечке - в
    Майку.
  

 Немножко покрутим камеру, чтобы видеть одну только
    голову нашей модели – экспериментировать мы будем именно с головой.
    Выделяем голову, создаём в Hypershade новый материал – Create =>
    Materials => Lambert. Назначаем этот материал на голову овцы и
    начинаем с ним играться. Я не долго думал над примером и, по
    аналогии с предыдущими экспериментами, подключил к ламбертовскому
    diffuse – Noise:
  

 \gr{image073}
  

 Снова запускаем рендеринг – а рендерером у нас всё
    так же стоит Gelato – и с удивлением смотрим на
    результат:
  

 \gr{image075}
  

 Gelato подхватил настройки материалов из
    Hypershade, сконвертировал их в свои – и правильно отобразил новый
    материал. Оказывается, Mango знает о существовании Hypershade, в
    его поставке есть набор шейдеров для многих Hypershade-овских нод,
    из которых и конструируются готовые – шейдеры для Gelato? Нет, не
    шейдеры. Мы в очередной раз встретились с инновационным решением –
    Gelato позволяет накладывать несколько шейдеров на один объект,
    объединяя их в группы и более того – позволяя строить из таких
    шейдеров более сложные конструкции, передавая параметры и
    результаты работы из одного шейдера в другой. Давайте ещё раз
    посмотрим внутрь файла c:\\temp\\gelato.pyg:
  
\begin{lstlisting}[frame=single, framerule=0pt, framesep=10pt, xleftmargin=10pt, xrightmargin=10pt]
ShaderGroupBegin()
Shader( "surface", "maya|_place2dTexture", "place2dTexture1" )
Shader
    ( "surface", "maya_noise", "noise1", "float amplitude", 0.6529,
    "float depthMax", 4, "float frequency", 11.57, "float
    frequencyRatio", 2.1158, "float noiseType", 0, "float ratio",
    0.90082, "float threshold", 0.22316 )
ConnectShaders
    ("place2dTexture1", "outUV", "noise1", "uvCoord")
ConnectShaders
    ("place2dTexture1", "outUvFilterSize", "noise1",
    "uvFilterSize")
Shader( "surface", "maya_lambert", "lambert2", "color _color", (0.20932,
    0.166365, 0.9091) )
ConnectShaders("noise1", "outAlpha", "lambert2", "diffuse")
ShaderGroupEnd()
\end{lstlisting}
  

 Манго определил, что мы используем три ноды –
    place2dTexture, noise и lambert. Для этих нод в поставке Mango есть
    соответствующие шейдеры (загляните внутрь
    \$GELATOHOME/mango/shaders, чтобы узнать, какие ноды поддерживаются
    на данный момент). Далее создаётся группа шейдеров, в которой при
    помощи процедуры ConnectShaders воссоздаётся то построение, которое
    мы с вами только что делали визуально в HyperShade.
  

 Кто-то ещё считает, что SLIM – самое
    удобное для создания шейдеров средство? Пусть бросает читать на
    этом месте, а мы тем временем продолжим перестройку сознания и
    галоп по возможностям Gelato. Вернёмся в директорию c:\\temp и
    покажем, как сделать быстрый рендерер ещё быстрее. Удаляем
    gelato.bat, а бывшее его содержимое копируем в командную строку и
    запускаем:
  

gelato –iv gelato\_perspShape.pyg gelato.pyg
  

 Попутно открылась ещё одна возможность – несколько
    PYG-ов, заданных в качестве параметров, будут выполнены в той
    последовательности, в которой вы их задали – удобно для разделения
    обших настроек сцены и собственно геометрии. Но мы хотели ускорить
    просчёт сцены. Запускаем рендерер ещё раз, с чуть другими
    параметрами:
  

gelato
    -iv -preview 0.1 gelato\_perspShape.pyg gelato.pyg
  

 Результат появился практически мгновенно – мы
    используем специальный режим предварительного просмотра в несколько
    ухудшенном качестве. Можно ли отрендерить ещё быстрее? Да,
    можно:
  

gelato  -iv  -shade defaultsurface -preview 0.1 gelato\_perspShape.pyg gelato.pyg
  

 Мы отключили все шейдеры и вместо них использовали
    defaultsurface. Результат выглядит ужасно,  но получается очень быстро даже
    для самых сложных сцен и показывает гибкость настроек
    предварительного просмотра:
  

 \gr{image077}
  

 Мы могли бы и дальше расписывать особенности
    Gelato, упрощающие жизнь трёхмерщика, приводя всё новые и новые
    примеры – но вместо этого просто обозначим один факт: этот рендерер
    является более расширяемым, чем prman, и вся его философия – это
    философия расширяемости. Хотите собственные операторы в GSL,
    аналогичные таковым в Renderman SL? Есть. Хотите рендерить в
    собственные форматы картинок? Есть открытый простой API, с помощью
    которого можно не только выводить в ваш формат данных (как в случае
    с display drivers у Renderman), так и импортировать эти данные – и
    изначально поддерживаются TIFF, Maya IFF, JPEG, PNG, PPM, TGA, HDR,
    DDS (сжатые текстуры для использования в DirectX) и, конечно же,
    OpenEXR. Хотите использовать собственный формат сцены? Пишете
    плагин или переводите в RIB или PYG. Хотите встроить рендерер в
    pipeline своей студии? У вас в руках мощнейший язык
    программирования Python, поддерживаемый этим рендерером. Хотите
    рендерить по слоям? Обсчитывать геометрию в shading grid, а потом
    использовать Gelato исключительно для решейдинга? Планка,
    установленная Renderman Pro Server,  поднята на новую высоту новым
    продуктом Nvidia. И индустрия это чувствует – интерес к рендереру
    очень высок и, несмотря на молодость и новизну, поддерживающие его
    конвертеры, утилиты и плагины появляются, как грибы после
    дождя.
  

 Должен признаться. Вернее, я должен быть признаться
    ещё в начале нашего рассказа про Gelato. Мне нравится этот
    рендерер. Он мне действительно очень нравится, почти так же (а по
    моему даже больше, прим. Редактора), как и prman. У меня есть
    видеокарта Quadro FX и я бета-тестер Nvidia – соответственно,
    имеющий доступ к внутренней информации (которая разглашению не
    подлежит) и бета-релизам (про которые я вам умудрился ни слова не
    рассказать, хотя очень хотелось). Мне тяжко осознавать, что я
    предаю свою искреннюю любовь к Renderman-у, но иногда, по вечерам,
    я тихонько закрываю дверь своей комнаты и вместо того, чтобы
    экспериментировать с prman’ом – исследую Гелато. Поэтому – ещё раз
    – мне нужно было признаться с самого начала в том, что я несколько
    пристрастный в данном случае человек – но если вы хотите
    беспристрастности – читайте отладочные дампы или судебные
    стенограммы.
  

 Что же у нас в сухом остатке? На рынке появился
    новый продукт, который в полной мере отвечает обозначенным нами
    критериям production-качества, прост для новичков, очень удобен и
    гибок в использовании в руках опытных пользователей. Но для того,
    чтобы воспользоваться всеми этими преимуществами, вам понадобится
    современный компьютер, оснашёный мощной профессиональной
    видеокартой последнего поколения от Nvidia – то есть денег этой
    компании вы заплатите два раза, сначала за рендерер, а потом за
    видеокарту (и третий раз – за саппорт). Стоит ли этих денег как
    минимум 2х-кратное (полученное мной в ходе антинаучных
    экспериментов, на одинаковых простых тестовых сценах, на одном и
    том же компьютере, gelato 1.0R3 в сравнении с prman 11.5.3)
    ускорение просчёта сцены? Решать вам.
  

 Для
    продвинутых: говорят, аборигены в
    лесах Амазонии знают, как запустить Gelato на игровых видеокартах,
    равно как на ноутбуках  без Quadro FX. Это сакральное знание передаётся ними на закрытых
    форумах в виде патчей к драйверам Nvidia, которые позволяют обычной
    видеокарте эмулировать хай-эндовую – благо элементная база у них
    одинаковая. Даже и не знаю, что сказать по этому
    поводу.