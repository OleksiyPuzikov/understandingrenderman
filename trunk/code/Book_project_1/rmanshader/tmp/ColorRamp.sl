/*
** Copyright (c) 2001 PIXAR.  All rights reserved.  This program or
** documentation contains proprietary confidential information and trade
** secrets of PIXAR.  Reverse engineering of object code is prohibited.
** Use of copyright notice is precautionary and does not imply
** publication.
**
**                      RESTRICTED RIGHTS NOTICE
**
** Use, duplication, or disclosure by the Government is subject to the
** following restrictions:  For civilian agencies, subparagraphs (a) through
** (d) of the Commercial Computer Software--Restricted Rights clause at
** 52.227-19 of the FAR; and, for units of the Department of Defense, DoD
** Supplement to the FAR, clause 52.227-7013 (c)(1)(ii), Rights in
** Technical Data and Computer Software.
**
** Pixar
** 1200 Park Ave
** Emeryville, CA 94608
**
** ----------------------------------------------------------------------------
*/
/* code generated by slim 6.0, RAT 6.0 (Mar 11 2004 04:21:00) */
/* for kidd@localhost at: Sat Mar 12 19:38:23 FLE Standard Time 2005 */

/* includes ---------------------------------*/

/* defines ----------------------------------*/
#define SLIM_TYPEID_surface 0
#define SLIM_TYPEID_displacement 1
#define SLIM_TYPEID_volume 2
#define SLIM_TYPEID_light 3
#define SLIM_VERSION 600
#define SLIM_SHADERTYPE surface
#define SLIM_SHADERTYPEID SLIM_TYPEID_surface
#define SLIM_INSTANCETYPE color
#define SLIM_INSTANCENAME ColorRamp

/* shader body ------------------------------*/
SLIM_SHADERTYPE
SLIM_INSTANCENAME (
)
{

/* static functions ----------------------*/

		void pxslST (
			  uniform float angle;
			  uniform float repeatS; uniform float repeatT;
			  uniform float offsetS; uniform float offsetT;
			  output point Q;
			  output vector dQu;
			  output vector dQv;
			  )
		{
		    extern float s, t, du, dv;

		    setxcomp(Q, repeatS * s + offsetS);
		    setycomp(Q, repeatT * t + offsetT);
		    setzcomp(Q, 0);

		    if(angle != 0)
			Q = rotate(Q, radians(angle), 
			    	    point(0,0,0), point(0,0,1)); 

		    dQu = vector Du(Q)*du;
		    dQv = vector Dv(Q)*dv;
		}
	    

#include "pxslUtil.h"
	   void
	   pxslColorRamp( float RampType;
		 float tile;
		 float numKnots;
		 float k0; color c0; 
		 float k1; color c1; 
		 float k2; color c2;
		 float k3; color c3;
		 float k4; color c4;
		 float k5; color c5;
		 float k6; color c6;
		 float k7; color c7;
		 float k8; color c8;
		 float k9; color c9;
		 float k10; color c10;
		 float k11; color c11;
		 float k12; color c12;
		 float k13; color c13;
		 float k14; color c14;
		 float k15; color c15;
                 float k16; color c16; 
                 float k17; color c17; 
		 float k18; color c18;
		 float k19; color c19;
		 float k20; color c20;
		 float k21; color c21;
		 float k22; color c22;
		 float k23; color c23;
		 float k24; color c24;
		 float k25; color c25;
		 float k26; color c26;
		 float k27; color c27;
		 float k28; color c28;
		 float k29; color c29;
		 float k30; color c30;
		 float k31; color c31;
		 point Q;
		 vector dQu;
		 vector dQv;
		 output color result;
		)
	   {
	       float k, s, t;
	       if( RampType <= 1 ) /* uramp, vramp */
	       {
		   if( RampType == 0 )
		   {
		       s = xcomp(Q);
		   }
		   else
		   {
		       s = ycomp(Q);
		   }
		   if( tile == 1 )
		       s = s - floor(s);
		   else
		       s = clamp(s, 0, 1);
		   k = float spline( "solvecatrom", s, 
			   k0, k1, k2, k3, k4, k5,
			   k6, k7, k8, k9, k10, k11,
			   k12, k13, k14, k15,
		           k16, k17, k18, k19, k20, k21,
			   k22, k23, k24, k25, k26, k27,
			   k28, k29, k30, k31);
		   result = color spline( "catrom", k, 
			   c0, c1, c2, c3, c4, c5, 
			   c6, c7, c8, c9, c10, c11,
			   c12, c13, c14, c15,
		           c16, c17, c18, c19, c20, c21, 
			   c22, c23, c24, c25, c26, c27,
			   c28, c29, c30, c31);
	       }
	       else
	       {
		   uniform float pi2 = 2 * PI;
		   float ss, tt;
		   s = xcomp(Q);
		   t = ycomp(Q);
		   if( tile == 1 )
		   {
		       s = s - floor(s);
		       t = t - floor(t);
		   }
		   if(RampType == 2) /* diagonal */
		   {
		       ss = (s + t) / 2.0;
		   }
		   else
		   if(RampType == 3) /* radial */
		   {
		       ss = (atan(t-.5, s-.5) + PI) / pi2;
		   }
		   else
		   if(RampType == 4) /* circular */
		   {
		       ss = s - .5;
		       tt = t - .5;
		       ss = 1 - sqrt(2 * (ss * ss + tt * tt));
		   }
		   else 
		   if(RampType == 5) /* box */
		   {
		       ss = s - .5;
		       tt = t - .5;
		       if( abs(ss) < abs(tt) )
			   ss = tt;
		       ss = 1 - sqrt(2*(2*ss*ss));
		   }
		   if(RampType != 6)
		   {
		       if(tile != 1)
			    ss = clamp(ss, 0, 1);
		       k = float spline( "solvecatrom", ss, 
			   k0, k1, k2, k3, k4, k5,
			   k6, k7, k8, k9, k10, k11,
			   k12, k13, k14, k15,
		           k16, k17, k18, k19, k20, k21,
			   k22, k23, k24, k25, k26, k27,
			   k28, k29, k30, k31);
		       result = color spline( "catrom", k, 
			   c0, c1, c2, c3, c4, c5, 
			   c6, c7, c8, c9, c10, c11,
			   c12, c13, c14, c15,
		           c16, c17, c18, c19, c20, c21, 
			   c22, c23, c24, c25, c26, c27,
			   c28, c29, c30, c31 );
		   }
		   else  /* 4 corner */
		   {
		       /* collect samples at four "adjacent" points */
		       color C0, C1, C2, C3;
		       float f;
		       ss = s - .5;
		       tt = t - .5;
		       C0 = pxslBimix( c1, c2, c3, c4, ss + .5, tt + .5 );
		       C1 = pxslBimix( c1, c2, c3, c4, ss - .5, tt + .5 );
		       C2 = pxslBimix( c1, c2, c3, c4, ss + .5, tt - .5 );
		       C3 = pxslBimix( c1, c2, c3, c4, ss - .5, tt - .5 );

		       /* mix the corner pieces */
		       f = filterstep( .5, ss );
		       C0 = mix(C0, C1, f);
		       C1 = mix(C2, C3, f);
		       result = mix(C0, C1, filterstep(.5, tt));

		       /* final anti-aliasing */
		       f = smoothstep(.125, .5, area(point(ss,tt,0)));
		       result = mix(result, pxslBimix(c1,c2,c3,c4,.5,.5), f);
		   }
	       }
	   }
       

/* dynamic functions ------------------------*/

/* local variables --------------------------*/
  point tmp0;
  color tmp3;
  vector tmp1;
  vector tmp2;

/* main body --------------------------------*/
  pxslST ( /* ST */
    0, /* Angle */
    1, /* S Repeats */
    1, /* T Repeats */
    0, /* S Offset */
    0, /* T Offset */
    tmp0, /* Q */ 
    tmp1, /* dQu */ 
    tmp2  /* dQv */ 
    );
  pxslColorRamp ( /* ColorRamp */
    0, /* RampType */
    0, /* Tile */
    7, /* numKnots */
    0, /* k0 */
    color(0,0,0), /* c0 */
    0, /* k1 */
    color(0,0,0), /* c1 */
    0.257142857143, /* k2 */
    color(0.94,0.254886701762,0.254886701762), /* c2 */
    0.521428571429, /* k3 */
    color(0.521568627451,0.905,0.521568627451), /* c3 */
    0.8, /* k4 */
    color(0.8,0.8,0.8), /* c4 */
    1, /* k5 */
    color(1,1,1), /* c5 */
    1, /* k6 */
    color(1,1,1), /* c6 */
    0, /* k7 */
    color(0,0,0), /* c7 */
    0, /* k8 */
    color(0,0,0), /* c8 */
    0, /* k9 */
    color(0,0,0), /* c9 */
    0, /* k10 */
    color(0,0,0), /* c10 */
    0, /* k11 */
    color(0,0,0), /* c11 */
    0, /* k12 */
    color(0,0,0), /* c12 */
    0, /* k13 */
    color(0,0,0), /* c13 */
    0, /* k14 */
    color(0,0,0), /* c14 */
    0, /* k15 */
    color(0,0,0), /* c15 */
    0, /* k16 */
    color(0,0,0), /* c16 */
    0, /* k17 */
    color(0,0,0), /* c17 */
    0, /* k18 */
    color(0,0,0), /* c18 */
    0, /* k19 */
    color(0,0,0), /* c19 */
    0, /* k20 */
    color(0,0,0), /* c20 */
    0, /* k21 */
    color(0,0,0), /* c21 */
    0, /* k22 */
    color(0,0,0), /* c22 */
    0, /* k23 */
    color(0,0,0), /* c23 */
    0, /* k24 */
    color(0,0,0), /* c24 */
    0, /* k25 */
    color(0,0,0), /* c25 */
    0, /* k26 */
    color(0,0,0), /* c26 */
    0, /* k27 */
    color(0,0,0), /* c27 */
    0, /* k28 */
    color(0,0,0), /* c28 */
    0, /* k29 */
    color(0,0,0), /* c29 */
    0, /* k30 */
    color(0,0,0), /* c30 */
    0, /* k31 */
    color(0,0,0), /* c31 */
    tmp0, /* inQ */ 
    tmp1, /* indQx */ 
    tmp2, /* indQy */ 
    tmp3  /* result */ 
    );
  Ci = tmp3;
  Oi = color(1,1,1);
}

