 \chapter*{prman или Закапываемся.}
  В 1642 году известный голландский мореплаватель
    Абель Тасман во главе экспедиции из двух кораблей отплыл из
    Джакарты на поиски новой земли на стыке Тихого и Индийского океана.
    В ходе своих скитаний путешественник открыл Тасманию, Новую
    Зеландию, острова Фиджи – и при этом умудрился проплыть мимо
    Австралии!

  Я ничего не имею против Новой Зеландии (скорее
    наоборот), но человек, пытающийся использовать prman исключительно
    при помощи RAT, не рассматривая взаимодействие этих программ,
    уподобляется славному голландскому первооткрывателю – как Тасман
    всё-таки открыл Австралию через 2 года после первого путешествия,
    так и незадачливый исследователь Renderman всё равно откроет для
    себя командную строку. И вот тогда он, наконец, поймёт, сколько
    всего интересного скрывал под поверхностью океана
    айсберг.

  К сожалению, не многие проходят этот путь, цепляясь
    за визуальные инструменты и пытаясь как можно дольше не погружаться
    в глубины EXE-файлов и их параметров. Их позывные слышны издалека:
    “Я художник, я не понимаю этого вашего всего, оно мне не нужно,
    пусть программисты копаются, а мне сделают мегакнопку”.
 
 И очень даже напрасно, хочу вам сказать, потому что
    истинная сила всех standalone рендереров – именно там, в командной
    строке.

\section*{prman.exe}

 Большинство Renderman-совместимых рендереров
    состоит из 3х программ – собственно рендерера, компилятора шейдеров
    и компилятора текстур.

  Не столь важно, получилось ли так исторически или
    все рендерман-совместимо-рендерерописатели смотрели на Pixar в
    качестве образца – но подобная тройственная архитектура сохраняется
    с теми или иными отклонениями во всех таких рендерерах. Отчасти в
    этом есть некая дань стремлению к максимальной оптимизации процесса
    и разделению рендерера на независимые модули; отчасти – это отклик
    Unix-овского наследия; отчасти – это слепок самой идеи, заложенной
    в спецификацию Renderman (согласно которой, процедурные материалы
    (шейдеры) и описание геометрии хранятся в разных файлах,
    соответственно, в *.SL и в *.RIB). Так или иначе, тенденция есть и
    она сохраняется даже в случае с самыми современными рендерерами –в
    их поставке вы тоже обнаружите 3 exe-шника: рендерер, компилятор
    шейдеров и конвертер текстур.

  В этом изысканном трио основная программа – это,
    конечно, сам рендерер – prman.

  Вызовите свою любимую командную строку (если вы
    используете Windows, то для этого нужно в пункте стартового меню
    Run запустить cmd.exe) и уже в новом окне командной строки
    запустите на выполнение prman.exe. 

\gr{image037}
 
 У новичков может возникнуть впечатление, что
    программа зависла, потому что сразу после запуска ничего не
    произошло и обратно в командную строку мы не вернулись. На самом
    деле мы столкнулись ещё с одной особенностью программ, изначально
    написанных в расчёте на консоль Unix – эти программы предназначены,
    в том числе, и для работы в режиме пайпинга, то есть передачи
    данных от одной программы к другой. Так вот, если такую программу
    запустить на выполнение, не указав параметров, то она будет
    ожидать, что данные будут поступать на вход от других программ (для
    продвинутых: из stdin) или будут набираться с клавиатуры. Значит,
    всё, что нам нужно сделать – это запустить программу с
    параметрами.

  Остановим этот экземпляр рендерера при помощи
    клавиатурной комбинации Ctrl-C. Возьмём образец текстового
    RIB-файла из начала нашей главы и сохраним его как test1.rib.
    Стойте, не нужно судорожно листать наше повествование в обратном
    направлении, вот необходимый код (он также есть на
    диске):

\code{code/rib_example/test1.rib}

Повторим наш экзерсис с рендерером, на этот раз
    передав программе в качестве параметра имя test1.rib:

  \gr{image039}
 
 Как видите, в результате получилось... хм... ничего
    у нас не получилось. В чём причина? Причин на самом деле несколько,
    и все они достаточно очевидны:
  
     В нашей примитивной сцене нет источников света.
      Поэтому сцена получилась полностью неосвещённой (умное название для
      эффекта “ничего не видно”)
     В нашей сцене используется (это не очень очевидно)
      полигональный объект, расположенный таким образом, чтобы полностью
      покрывать видимое пространство (это совсем неочевидный факт, но
      можете поверить мне на слово).
  
  Использовать в качестве упражнения на рендеринг в
    книжке полигон, находящийся в чёрной-чёрной сцене – это, в общем,
    готично, но при этом не совсем педагогически правильно. Поэтому нам
    с вами нужно немножко поработать над нашим RIBом, чтобы
    получить хоть сколько-нибудь удобоваримую картинку. Я сделал эти
    исправления вручную в текстовом редакторе, вы можете просто
    скопировать текст из книги или из файла test2.rib:

	\code{code/rib_example/test2.rib}

  Записываем этот файл поверх старого и повторяем
    вызов рендерера:

 \gr{image041}

  Вот, совсем другое дело. Поздравляю вас с
    приобщением к великой могучей командной строке и обществу её
    последователей и почитателей.

  Если вы хорошо рассмотрели скриншот с командной
    строкой, то обратили внимание, что команда, которую мы выполняли,
    выглядит вот так:

\begin{lstlisting}[frame=single, framerule=0pt, framesep=10pt, xleftmargin=10pt, xrightmargin=10pt, basicstyle=\ttfamily \small, backgroundcolor=\color{light-gray}]
prman test1.rib
\end{lstlisting}

  Это не единственный возможный способ передачи
    информации в рендерер; как один из примеров, мы можем
    воспользоваться тем самым пайпингом (или туннелированием, как его
    называют некоторые несознательные юниксоиды-русофилы):

\begin{lstlisting}[frame=single, framerule=0pt, framesep=10pt, xleftmargin=10pt, xrightmargin=10pt, basicstyle=\ttfamily \small, backgroundcolor=\color{light-gray}]
type test1.rib | prman
\end{lstlisting}

  Результат будет в точности такой же. Но это ещё не
    всё. Вы же знаете, что туннелировать можно не только 2 программы,
    но и целые цепочки программ?

  В качестве примера (скриптоненавистники могут
    перевернуть страницу) напишем небольшой скрипт на Perl, который
    будет заменять объявление материала Plastic на объявление материала
    Stone. Делаем новый файл, называем его magic.pl и пишем нечто
    подобное:

\begin{lstlisting}[frame=single, framerule=0pt, framesep=10pt, xleftmargin=10pt, xrightmargin=10pt, basicstyle=\ttfamily \small, backgroundcolor=\color{light-gray}]
foreach (<>) {
  s/plastic/stone/;
  print;
}
\end{lstlisting}
  
Наша цепочка выполняемых программ в данном случае
    немного изменится и будет выглядеть так (я переименовал
    RIB-файл):

\begin{lstlisting}[frame=single, framerule=0pt, framesep=10pt, xleftmargin=10pt, xrightmargin=10pt, basicstyle=\ttfamily \small, backgroundcolor=\color{light-gray}]
type test2.rib | perl magic.pl | prman
\end{lstlisting}
  
 Читаем написанное слева направо: распечатать в
    консоль файл test2.rib и передать результат в программу perl,
    которая выполняет файл magic.pl, который заменяет все нахождения
    слова plastic на слово stone и опять печатает в консоль. Вывод этой
    консоли передаётся собственно рендереру:

\gr{image043}
  
Для того, чтобы это сработало на вашей машине (если вы не сидите сейчас за Unix-терминалом), вам понадобится установить на своём
компьютере интерпретатор языка программирования Perl (например, ActivePerl).

  Лирическое
    отступление: Perl, по искреннему
    мнению многих, и я к нему присоединяюсь – язык программирования для
    истинных криптоманьяков. Расшифровывать свои собственные скрипты
    через полтора года с момента  последнего их использования –
    занятие, доставляющее нереальное удовольствие. Так прямо себе и
    представляю: Блетчли-Парк, Вторая Мировая война, взломавший Энигму
    Тьюринг никак не может разобраться в перловом скрипте из 4х
    строк.

  Вы уже слышите, как тихонько зазвучало в воздухе
    исконно русское слово “pipeline”? Просто подумайте о тех
    невероятных возможностях, дверь к которым мы только что приоткрыли.
    Получается, что геометрию для рендерера совсем не обязательно
    выводить из Maya (или 3dsmax, или Houdini, или на самом деле
    неважно откуда именно) – вы можете сами писать небольшие программы
    или скрипты, которые будут или создавать новые файлы RIB, или
    модифицировать уже существующие. Более того, файлы эти можно
    запросто открывать в текстовых редакторах, делать замены,
    переставлять куски местами, экспериментировать с различными
    возможностями – и всё это без запуска и использования безумных
    систем моделирования и анимации. Да что уж там – изучение текста
    сгенерированных RIBов представляет из себя захватывающее
    интеллектуальное психоделическое путешествие в мир 3хмерной графики
    и во внутреннее устройство вашего любимого моделлера. Как
    подействует это изменение в модели на RIB? Что изменится, если
    сделать то или это? Какая картинка получится в том или ином
    случае?

  Лирическое
    отступление: Что уж говорить – я
    сам прошёл через это увлечение текстовыми рендерерами, но у меня
    оно началось не с Renderman-совместимых. Первым рендерером, который
    я запустил на своём новеньком, свежесобранном (Тёма, спасибо тебе!),
    с иголочки 486DX4-100, был Vivid. Где-то в то же время на моём
    жестком диске гостили ещё и DKB с PovRay’ем в ранних версиях
    (собственно, PovRay является развитием DKB, если мне не изменяет
    память), но Vivid – это было наше всё. Быстрый рейтрейсер, простой
    входной формат данных, полноцветный выход – целых 24
    бита!

  Не один вечер
    провёл я в экспериментах с картинками и скриптами, в попытках
    сделать тот или иной элемент, материал, эффект. Рендерер этот был
    действительно быстрым, быстрее PovRay чуть ли не в десятки раз
    (жаль, он не запускается под Windows XP – уж очень хочется
    проверить эти мои старые ощущения на новом железе). Такая скорость
    позволяла мне за вечер перепробовать множество вариантов, получить
    множество красивых – и не очень – результатов. В общем, это была
    любовь с первого зеркального шарика (стоящего на шахматной доске –
    а как же без этого).

  Ау, [название
    удалено по понятным причинам] продукт отечественного 3хмерного
    софтостроения! На совести вашего криво написанного деинсталлятора –
    все мои картинки, исходники к ним, равно как и всё остальное
    содержимое моего славного боевого друга и товарища - диска С!
    Надеюсь, в славном 199x-ом году вам славно
    поикалось.
  
Первый
    Renderman-совместимый был потом, и был это – BMRT. Но это уже –
    современная история, с Интернетом, Амазоном, Пентиумами и
    ньюсгруппами.

  Впрочем, я немного увлёкся.